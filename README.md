# ESLint Plugin: VibeCoding 🤖🚫

> **Stop robots from ruining your code vibes!**

This ESLint plugin contains custom rules designed to prevent common bad practices that AI assistants (and humans who code like robots) often make. Because sometimes the best code is the code that doesn't overthink everything.

## 🎯 What This Plugin Does

We've all been there - you ask an AI to help with some code, and it gives you a 500-line solution for a problem that could be solved in 10 lines. Or it creates variable names that look like they were generated by a random string generator. This plugin helps prevent those "robot moments" in your codebase.

## 🚀 Installation

```bash
npm install --save-dev eslint-plugin-vibecoding
```

## 🔄 CI/CD

This project uses GitHub Actions for continuous integration and deployment. The workflow automatically:

- Builds and tests on multiple Node.js versions
- Publishes to npm on push to main branch
- Creates GitHub releases on tag pushes

See [`.github/README.md`](.github/README.md) for detailed setup instructions.

## 📝 Usage

Add `vibecoding` to your ESLint configuration:

```json
{
  "extends": ["plugin:vibecoding/recommended"]
}
```

Or configure individual rules:

```json
{
  "plugins": ["vibecoding"],
  "rules": {
    // Rules will be configured here
  }
}
```

## 🛡️ Rules

### `no-optional-properties`

Prevents optional properties in TypeScript types and interfaces to encourage explicit design decisions. Optional properties often indicate unclear requirements or lazy design.

**Why this rule exists:**
Optional properties can make code harder to understand and maintain. They often indicate that the developer hasn't thought through the requirements clearly. This rule prevents all forms of optional properties to encourage explicit design decisions.

**Examples:**

❌ **Bad:**

```typescript
interface User {
  name?: string; // Error: Optional property
  avatar: string | null; // Error: Union with null
  metadata: string | undefined; // Error: Union with undefined
  email: string;
}

// Type aliases with optional properties
type UserConfig = {
  theme?: 'light' | 'dark'; // Error: Optional property
  language: string;
};

// Intersection types with optional properties
interface Base {
  name: string;
}
interface Optional {
  email?: string;
}
type Combined = Base & Optional; // Error: email is optional

// Index signatures with optional types
interface Config {
  [key: string]: string | undefined; // Error: Values can be undefined
}
```

✅ **Good:**

```typescript
interface User {
  name: string; // Required property
  avatar: string; // Required property
  metadata: string; // Required property
  email: string;
}

// Type aliases with required properties
type UserConfig = {
  theme: 'light' | 'dark'; // Required property
  language: string;
};

// Intersection types with required properties
interface Base {
  name: string;
}
interface Extended {
  email: string;
}
type Combined = Base & Extended; // All properties required

// Index signatures with required types
interface Config {
  [key: string]: string; // All values required
}
```

**Configuration:**

```json
{
  "rules": {
    "vibecoding/no-optional-properties": "error"
  }
}
```

## 🚀 Releasing

To release a new version:

```bash
# For patch releases (1.0.0 -> 1.0.1)
npm run release:patch

# For minor releases (1.0.0 -> 1.1.0)
npm run release:minor

# For major releases (1.0.0 -> 2.0.0)
npm run release:major
```

The release script will:

1. Update the version in `package.json`
2. Build and test the project
3. Commit changes and create a git tag
4. Push to GitHub, triggering the CI/CD pipeline
5. Automatically publish to npm

## 🔍 Edge Cases Not Currently Detected

The rule currently detects basic optional properties and union types with `undefined`/`null`, but some advanced TypeScript patterns are not yet covered:

- **Type Aliases with Optional Properties**: `type UserConfig = { theme?: 'light' | 'dark' }`
- **Intersection Types with Optional Properties**: `type Combined = Base & Optional`
- **Index Signatures with Optional Types**: `interface Config { [key: string]: string | undefined }`
- **Generic Type Parameters**: `interface Container<T = string>`
- **Conditional Types**: `type OptionalIf<T, U> = T extends U ? string | undefined : string`
- **Mapped Types**: `type Partial<T> = { [P in keyof T]?: T[P] }`
- **Utility Types**: `Partial<User>`, `PickOptional<T, K>`
- **Function Parameter Types**: `(data: string | undefined) => void`
- **Template Literal Types**: `type OptionalField<T> = \`${string & keyof T}?\``
- **Complex Union Types**: Union types with optional branches in complex structures

The first three edge cases (Type Aliases, Intersection Types, Index Signatures) are planned for future implementation.

## 🤖 Why "Anti-Robot" Rules?

Let's be honest - AI assistants (including the one that might have helped write this README 😄) have some common tendencies:

1. **Over-engineering everything** - Why use a simple function when you can create a full-blown class hierarchy?
2. **Verbose naming** - `calculateUserAuthenticationTokenValidationStatus` instead of `isValidToken`
3. **Magic patterns** - Using complex design patterns when a simple approach would work
4. **Copy-paste syndrome** - Repeating the same boilerplate everywhere
5. **Documentation overkill** - Commenting every single line of obvious code

This plugin helps keep your code human-friendly and maintainable.

## 🛠️ Development

### Prerequisites

- Node.js 18+
- ESLint 8+

### Setup

```bash
npm install
npm run build
```

### Testing

```bash
npm test
```

### Linting

```bash
npm run lint
npm run lint:fix
```

## 📄 License

MIT - Feel free to use this to keep your codebase robot-free!

## 🤝 Contributing

Have an idea for a rule that prevents robot coding practices? We'd love to hear it! Just make sure your contribution follows the vibe coding principles - keep it simple and human-readable.

---

_Remember: The best code is the code that another human can understand and maintain. Let's keep it that way!_ 🎉
